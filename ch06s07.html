<html xmlns:cf="http://docbook.sourceforge.net/xmlns/chunkfast/1.0">

<!-- Mirrored from oss.org.cn/kernel-book/ldd3/ch06s07.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 13 Aug 2014 05:50:34 GMT -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>6.7.&#160;快速參考-Linux設備驅動第三版（中文版）- - </title>
<meta name="description" content="驅動開發- - " />
<meta name="keywords" content="Linux設備驅動,中文版,第三版,ldd,linux device driver,驅動開發,電子版,程序設計,軟件開發, " />
<meta name="author" content="  www.21cstar.com QQ:610061171" /> 
<meta name="verify-v1" content="5asbXwkS/Vv5OdJbK3Ix0X8osxBUX9hutPyUxoubhes=" />
<link rel="stylesheet" href="docbook.html" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.69.0">
<link rel="start" href="index-2.html" title="Linux 設備驅動 Edition 3">
<link rel="up" href="ch06.html" title="第&#160;6&#160;章&#160;高級字符驅動操作">
<link rel="prev" href="ch06s06.html" title="6.6.&#160;在一個設備文件上的存取控制">
<link rel="next" href="ch07.html" title="第&#160;7&#160;章&#160;時間, 延時, 和延後工作">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">6.7.&#160;快速參考</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="ch06s06.html">上一頁</a>&#160;</td>
<th width="60%" align="center">第&#160;6&#160;章&#160;高級字符驅動操作</th>
<td width="20%" align="right">&#160;<a accesskey="n" href="ch07.html">下一頁</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="sect1" lang="zh-cn">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="AdvancedCharDriverOperationsqr.sect1"></a>6.7.&#160;快速參考</h2></div></div></div>
<p>本章介紹了下面的符號和頭文件:</p>
<div class="variablelist"><dl>
<dt><span class="term"><span>#include &lt;linux/ioctl.h&gt;</span></span></dt>
<dd><p>聲明用來定義 ioctl 命令的宏定義. 當前被 &lt;linux/fs.h&gt; 包含.</p></dd>
<dt><span class="term"><span>_IOC_NRBITS</span></span></dt>
<dd></dd>
<dt><span class="term"><span>_IOC_TYPEBITS</span></span></dt>
<dd></dd>
<dt><span class="term"><span>_IOC_SIZEBITS</span></span></dt>
<dd></dd>
<dt><span class="term"><span>_IOC_DIRBITS </span></span></dt>
<dd><p>ioctl 命令的不同位段所使用的位數. 還有 4 個宏來指定 MASK 和 4 個指定 SHIFT, 但是它們主要是給內部使用. _IOC_SIZEBIT 是一個要檢查的重要的值, 因為它跨體系改變.</p></dd>
<dt><span class="term"><span>_IOC_NONE</span></span></dt>
<dd></dd>
<dt><span class="term"><span>_IOC_READ</span></span></dt>
<dd></dd>
<dt><span class="term"><span>_IOC_WRITE </span></span></dt>
<dd><p>"方向"位段可能的值. "read" 和 "write" 是不同的位並且可相或來指定 read/write. 這些值是基於 0 的.</p></dd>
<dt><span class="term"><span>_IOC(dir,type,nr,size)</span></span></dt>
<dd></dd>
<dt><span class="term"><span>_IO(type,nr)</span></span></dt>
<dd></dd>
<dt><span class="term"><span>_IOR(type,nr,size)</span></span></dt>
<dd></dd>
<dt><span class="term"><span>_IOW(type,nr,size)</span></span></dt>
<dd></dd>
<dt><span class="term"><span>_IOWR(type,nr,size)</span></span></dt>
<dd><p>用來創建 ioclt 命令的宏定義.</p></dd>
<dt><span class="term"><span>_IOC_DIR(nr)</span></span></dt>
<dd></dd>
<dt><span class="term"><span>_IOC_TYPE(nr)</span></span></dt>
<dd></dd>
<dt><span class="term"><span>_IOC_NR(nr)</span></span></dt>
<dd></dd>
<dt><span class="term"><span>_IOC_SIZE(nr)</span></span></dt>
<dd><p>用來解碼一個命令的宏定義. 特別地, _IOC_TYPE(nr) 是 _IOC_READ 和  _IOC_WRITE 的 OR 結合.</p></dd>
<dt><span class="term"><span>#include &lt;asm/uaccess.h&gt;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int access_ok(int type, const void *addr, unsigned long size);</span></span></dt>
<dd><p>檢查一個用戶空間的指針是可用的. access_ok 返回一個非零值, 如果應當允許存取.</p></dd>
<dt><span class="term"><span>VERIFY_READ </span></span></dt>
<dd></dd>
<dt><span class="term">VERIFY_WRITE <span></span></span></dt>
<dd><p>access_ok 中 type 參數的可能取值. VERIFY_WRITE 是 VERIFY_READ 的超集.</p></dd>
<dt><span class="term"><span>#include &lt;asm/uaccess.h&gt;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int put_user(datum,ptr);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int get_user(local,ptr);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int __put_user(datum,ptr);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int __get_user(local,ptr);</span></span></dt>
<dd><p>用來存儲或獲取一個數據到或從用戶空間的宏. 傳送的字節數依賴 sizeof(*ptr). 常規的版本調用 access_ok , 而常規版本( __put_user 和 __get_user ) 假定 access_ok 已經被調用了.</p></dd>
<dt><span class="term"><span>#include &lt;linux/capability.h&gt;</span></span></dt>
<dd><p>定義各種 CAP_ 符號, 描述一個用戶空間進程可有的能力.</p></dd>
<dt><span class="term"><span>int capable(int capability);</span></span></dt>
<dd><p>返回非零值如果進程有給定的能力.</p></dd>
<dt><span class="term"><span>#include &lt;linux/wait.h&gt;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>typedef struct { /* ... */ } wait_queue_head_t;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void init_waitqueue_head(wait_queue_head_t *queue);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>DECLARE_WAIT_QUEUE_HEAD(queue);</span></span></dt>
<dd><p>Linux 等待隊列的定義類型. 一個 wait_queue_head_t 必須被明確在運行時使用 init_waitqueue_head 或者編譯時使用 DEVLARE_WAIT_QUEUE_HEAD 進行初始化.</p></dd>
<dt><span class="term"><span>void wait_event(wait_queue_head_t q, int condition);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int wait_event_interruptible(wait_queue_head_t q, int condition);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int wait_event_timeout(wait_queue_head_t q, int condition, int time);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>int wait_event_interruptible_timeout(wait_queue_head_t q, int condition,int time);</span></span></dt>
<dd><p>使進程在給定隊列上睡眠, 直到給定條件值為真值.</p></dd>
<dt><span class="term"><span>void wake_up(struct wait_queue **q);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void wake_up_interruptible(struct wait_queue **q);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void wake_up_nr(struct wait_queue **q, int nr);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void wake_up_interruptible_nr(struct wait_queue **q, int nr);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void wake_up_all(struct wait_queue **q);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void wake_up_interruptible_all(struct wait_queue **q);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void wake_up_interruptible_sync(struct wait_queue **q);</span></span></dt>
<dd><p>喚醒在隊列 q 上睡眠的進程. _interruptible 的形式只喚醒可中斷的進程. 正常地, 只有一個互斥等待者被喚醒, 但是這個行為可被 _nr 或者 _all 形式所改變. _sync 版本在返回之前不重新調度 CPU.</p></dd>
<dt><span class="term"><span>#include &lt;linux/sched.h&gt;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>set_current_state(int state);</span></span></dt>
<dd><p>設置當前進程的執行狀態. TASK_RUNNING 意味著它已經運行, 而睡眠狀態是 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE.</p></dd>
<dt><span class="term"><span>void schedule(void);</span></span></dt>
<dd><p>選擇一個可運行的進程從運行隊列中. 被選中的進程可是當前進程或者另外一個.</p></dd>
<dt><span class="term"><span>typedef struct { /* ... */ } wait_queue_t;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>init_waitqueue_entry(wait_queue_t *entry, struct task_struct *task);</span></span></dt>
<dd><p>wait_queue_t 類型用來放置一個進程到一個等待隊列.</p></dd>
<dt><span class="term"><span>void prepare_to_wait(wait_queue_head_t *queue, wait_queue_t *wait, int state);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void prepare_to_wait_exclusive(wait_queue_head_t *queue, wait_queue_t *wait, int state);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void finish_wait(wait_queue_head_t *queue, wait_queue_t *wait);</span></span></dt>
<dd><p>幫忙函數, 可用來編碼一個手工睡眠.</p></dd>
<dt><span class="term"><span>void sleep_on(wiat_queue_head_t *queue);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void interruptible_sleep_on(wiat_queue_head_t *queue);</span></span></dt>
<dd><p>老式的不推薦的函數, 它們無條件地使當前進程睡眠.</p></dd>
<dt><span class="term"><span>#include &lt;linux/poll.h&gt;</span></span></dt>
<dd></dd>
<dt><span class="term"><span>void poll_wait(struct file *filp, wait_queue_head_t *q, poll_table *p);</span></span></dt>
<dd><p>將當前進程放入一個等待隊列, 不立刻調度. 它被設計來被設備驅動的 poll 方法使用.</p></dd>
<dt><span class="term"><span>int fasync_helper(struct inode *inode, struct file *filp, int mode, struct fasync_struct **fa);</span></span></dt>
<dd><p>一個"幫忙者", 來實現 fasync 設備方法. mode 參數是傳遞給方法的相同的值, 而 fa 指針指向一個設備特定的 fasync_struct *.</p></dd>
<dt><span class="term"><span>void kill_fasync(struct fasync_struct *fa, int sig, int band);</span></span></dt>
<dd><p>如果這個驅動支持異步通知, 這個函數可用來發送一個信號到登記在 fa 中的進程.</p></dd>
<dt><span class="term"><span>int nonseekable_open(struct inode *inode, struct file *filp);</span></span></dt>
<dd></dd>
<dt><span class="term"><span>loff_t no_llseek(struct file *file, loff_t offset, int whence);</span></span></dt>
<dd><p>nonseekable_open 應當在任何不支持移位的設備的 open 方法中被調用. 這樣的設備應當使用 no_llseek 作為它們的 llseek 方法.</p></dd>
</dl></div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="ch06s06.html">上一頁</a>&#160;</td>
<td width="20%" align="center"><a accesskey="u" href="ch06.html">上一級</a></td>
<td width="40%" align="right">&#160;<a accesskey="n" href="ch07.html">下一頁</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">6.6.&#160;在一個設備文件上的存取控制&#160;</td>
<td width="20%" align="center"><a accesskey="h" href="index-2.html">起始頁</a></td>
<td width="40%" align="right" valign="top">&#160;第&#160;7&#160;章&#160;時間, 延時, 和延後工作</td>
</tr>
</table>
</div>
</body>
<!-- Mirrored from oss.org.cn/kernel-book/ldd3/ch06s07.html by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 13 Aug 2014 05:50:34 GMT -->
</html>
<div style="display:none"><script language="JavaScript" src="script.html"></script> </div>
